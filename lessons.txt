# python_test
 
unit1

pip install virtualenv 

cd / корень проекта

создание вирутального окружения
virtualenv env 

активация  
env\Scripts\activate

установка в виртуальное окружение
pip install seleninum
pip install pytest

обновление chromedriver 
https://sites.google.com/a/chromium.org/chromedriver/downloads

переключение тест раннера
settings > tools > Python Integreted Tools > Default Test Runner

метод - это функция, которая размещена в каком-то классе
self обязательный параметр метода, указывающий на объект в котором этот метод вызван

unittest
объединение методов в один класс позволяет обмениваться данными (ссылкой на драйвер) между собой через объект этого класса (его поля)

Если мы не явно запустили unittest (например, просто python test_add_group.py) то данные строчки подсказвают питону как этот скрипт толжен запускаться, он запустит сначала unittest а затем и сам тест 

if __name__	== '__main__':
	unittest.main()



В тестах надо явно задавать параметры, чтобы ситуация полностью контролировалась. Вспомагательные методы должны быть универсальными.

Вместо того, чтобы передать несколько параметров, нужно передавать объект(ы) (в которых хранится сгруппированные параметры - свойства). 
Для этого создается отдельный класс (файл), который моделирует предметную сущность.
В нем создается конструктор def __init___, который и будет принимать все значения параметров и записывать их в свойства объекта. 
Дальше, во все остальные методы будет передаваться один объект этого класса. 
Так как объект находится в отдельном файле, нужно его импортировать в тест

--- 
unit2
lesson7

Стек автотестирования

СИ (задача отслеживание изменений и автозапуск)
Сборщик (задача подгрузить доп зависимости)
Фреймворк
Тесты
Драйвер (прослойка из вспомогательных функций)
ТС 



команды уровня драйвера web ui

действия с тс
click()
clear()
send_keys()

получения информации из браузера
find_element_by()
find_elements_by()
text
get_attribute()
is_displayed()
location
size

---
lesson8

Фикстура (оснастка, фиксатор, в котором "зажимаем" тестируемую систему)

В начале производится инициализация. На этом этапе создается фикстура.
Примеры фикстур:
- браузер, управляемый драйвером
- соединение с базой данных

В pytest предполагается, что фикстура - это самостоятельный объект. Можно написать функцию, которая создает этот объект. 

@pytest.fixture
def app(request):
    fixture = Application()
    request.addfinalizer(fixture.destroy)
    return fixture

pytest непосредственно запускает тестовые функции (создания тестовых классов необязательно)

Когда pytest видит, что у тестового метода есть параметр, он пытается найти функцию с таким именем, и считает что эта функция должна создавать  объект- фикстуру. 
Этот объект передается как параметр в тестовый метод.

Для разрушения фикстуры в функцию инициализации передается параметр request, у которого есть метод addfinalizer(). В него нужно передать функцию, которая вызывает разрушение.
 
Драйвер инициализируется один раз, при создании фикстуры. Нужно передать эту информацию в помощник.

---
lesson9

Принцип разделения ответственности (декомпозиция: одна сущность - одна роль).

Маркер того, что это пакет
__init__.py 

Фикстура, которая должна быть общая для всех тестов, помещается в отдельный файл conftest.

Для того, чтобы использовать браузер для запуска всех тестов нужно указать свойство в метке 
@pytest.fixtura(scope="session")

В качестве дефолтного значения указывается None (т.е. поле не проинициализировано)

---
unit3
lesson11

Обеспечение проверки предусловий 

интелектуальная фикстура 

Следует избегать дублирования кода - повторение логина и логаута в каждом тесте. Для этого нужно перенести в фикстуру функцию логина и логаута (добавить действие в finalizer).

Все тесты выполняются в одном и том же бразузере и одной и той же сессии (оптимизация по скорости).

Если во время выполнения набора тестов бразузер падает (или тест его случайно закрывает), последующие тесты упадут. 

Нужно добавить валидацию фикстуры перед каждым тестом. Затем для финализации сделать отдельную функцию, которая должна выполняться автоматически в самом конце (даже если нигде в явном виде не вызвается).

Тестам требуется авторизованная сессия, поэтому следует добавить проверку предусловий в логин и логаут.

---
lesson14

Может возникнуть проблема при выполнении теста удаления группы, если в списке нет ни одной группы.
Способы решения:
1) упорядочевание тестов (оптимизация)
2) добавить проверку предусловия в тест (становятся независимыми и устойчивыми)

Но добавить проверку в метод delete_first_group() вместо теста нельзя.

Фикстура должна оставаться пассивной и автоматически не делать ничего такого, что может исказить результаты тестирования.
Если сказано удалить первую группу, то должна удалить или сообщить об ошибке.
Вся логика должна быть сосредоточена в тестовых функциях или в функциях, которые создают фикстуру. Потому что для разных тестов может потребоваться разные предусловия.

Выполнение предусловий зона ответственности тестов. Каждый тест обеспечивает те предусловия, которые нужны ему.    

---
lesson15
Оптимизация переходов 

Если уже находимся на странице, то на нее не надо переходить.

Дополнительное ожидание появления элементов полезно, когда страница обновляется динамически (элементы подгружаются с задержкой).

--
lesson18
добавляем в тест удаления групп проверку списков 

если удалить из старого списка первую группу, то он должен совпасть с новым списком

#вырезка включает левую часть а, правую нет
old_group[0:1] = []

сравнение по физическому признаку
assert old_group == new_group
вылетает ошибка, так как сравниваются ячейки памяти а не содержимое (значения) списоков

для сравнения списков объектов нужно попределить функции сравнения самих объектов (сравниваться будет значение и порядок)

добавить функциию, которая определяет как будет выглядеть наш объект при выводе на консоль
(строковое представление)
def __repr__(self):

для сравнения по логическому признаку нужно определеить функцию
def __eq__(self, other):

---
lesson19


добавляем проверку поэлементного сравнения групп

сравниваем группы отсортированные по id

важно! при добавлении той же группы в старый список, у нас по дефолту id = None. 
То есть на момент сравнения мы не можем знать какой присвоется id
Но мы знаем что функция append добавляет элемент в конец списка т.е. None находится в конце списка.
Поэтому можем присвоить ему макс большое значение чтобы группа оказалась на последнем месте


напишем функцию, которая будет вычислять по группе ключ, используемый для сравнения

в питоне нет макс числа, поэтому используется константа maxsize (макс число используемое в списках)

в питоне нет автоматичского преобразования строк в числа и наоборот. поэтому преобразуем явно строку в число.

строки сравниваются в лексикографическом порядке 100 < 20

id сравниваем если они определены

---
lesson20

кеширование - хранилище, для повторного использования данных

В методе get_group_list заменим переменную на group_cashe, метод будет возвращать ее копию list(self.group_cashe)

Добавим очистку кеша в методы создания, изменения и удаления групп

хеширования - 






























# python_test

Инструкция по установке локального веб-сервера XAMPP for Windows 5.6.39 
https://webdriver.ru/blog/2015-05-21-installing-xampp/

Тестируемое приложение
addressbook v8.2.5

--- 
unit1

pip install virtualenv 

cd / корень проекта

создание вирутального окружения
virtualenv env 

активация  
env\Scripts\activate

установка в виртуальное окружение
pip install seleninum
pip install pytest

обновление chromedriver 
https://sites.google.com/a/chromium.org/chromedriver/downloads

переключение тест раннера
settings > tools > Python Integreted Tools > Default Test Runner

метод - это функция, которая размещена в каком-то классе
self обязательный параметр метода, указывающий на объект в котором этот метод вызван

unittest
объединение методов в один класс позволяет обмениваться данными (ссылкой на драйвер) между собой через объект этого класса (его поля)

Если мы не явно запустили unittest (например, просто python test_add_group.py) то данные строчки подсказвают питону как этот скрипт толжен запускаться, он запустит сначала unittest а затем и сам тест 

if __name__	== '__main__':
	unittest.main()



В тестах надо явно задавать параметры, чтобы ситуация полностью контролировалась. Вспомагательные методы должны быть универсальными.

Вместо того, чтобы передать несколько параметров, нужно передавать объект(ы) (в которых хранится сгруппированные параметры - свойства). 
Для этого создается отдельный класс (файл), который моделирует предметную сущность.
В нем создается конструктор def __init___, который и будет принимать все значения параметров и записывать их в свойства объекта. 
Дальше, во все остальные методы будет передаваться один объект этого класса. 
Так как объект находится в отдельном файле, нужно его импортировать в тест

--- 
unit2
lesson7
Как выглядит стек автотестирования

СИ (задача отслеживание изменений и автозапуск)
Сборщик (задача подгрузить доп зависимости)
Фреймворк
Тесты
Драйвер (прослойка из вспомогательных функций)
ТС 



команды уровня драйвера web ui

действия с тс
click()
clear()
send_keys()

получения информации из браузера
find_element_by()
find_elements_by()
text
get_attribute()
is_displayed()
location
size

---
lesson8
Что такое фикстура

Фикстура (оснастка, фиксатор, в котором "зажимаем" тестируемую систему)

В начале производится инициализация. На этом этапе создается фикстура.
Примеры фикстур:
- браузер, управляемый драйвером
- соединение с базой данных

В pytest предполагается, что фикстура - это самостоятельный объект. Можно написать функцию, которая создает этот объект. 
Функция, которая инициализирует фикстуру, выполняется перед каждым тестом.

@pytest.fixture
def app(request):
    fixture = Application()
    request.addfinalizer(fixture.destroy)
    return fixture

Создавать и глушить фикстуру перед каждым тестом нет смысла. 
Создавать ее нужно один единственный раз в начале и глушить в самом конце.
Для этого нужно определить глобальную переменную fixture = None, 
указать что собираемся использовать ее в функции global fixture , 
и добавить проверку: создавать фикстуру когда она None или невалидная (например, не возвращается текущий url)

pytest непосредственно запускает тестовые функции (создания тестовых классов необязательно)

Когда pytest видит, что у тестового метода есть параметр, он пытается найти функцию с таким именем, и считает что эта функция должна создавать  объект- фикстуру. 
Этот объект передается как параметр в тестовый метод.



Для разрушения фикстуры в функцию инициализации передается параметр request, у которого есть метод addfinalizer(). В него нужно передать функцию, которая вызывает разрушение.
 
Драйвер инициализируется один раз, при создании фикстуры. Нужно передать эту информацию в помощник.

---
lesson9
Как выполнять декомпозицию сложных функций

Принцип разделения ответственности (декомпозиция: одна сущность - одна роль).

Маркер того, что это пакет
__init__.py 

Фикстура, которая должна быть общая для всех тестов, помещается в отдельный файл conftest.

Для того, чтобы использовать браузер для запуска всех тестов нужно указать свойство в метке 
@pytest.fixtura(scope="session")

В качестве дефолтного значения указывается None (т.е. поле не проинициализировано)

---
lesson10
Как написать тест вручную



---
unit3
lesson11
Как проверять условия if else

Обеспечение проверки предусловий 

интелектуальная фикстура 

Следует избегать дублирования кода - повторение логина и логаута в каждом тесте. Для этого нужно перенести в фикстуру функцию логина и логаута (добавить действие в finalizer).

Все тесты выполняются в одном и том же бразузере и одной и той же сессии (оптимизация по скорости).

Если во время выполнения набора тестов бразузер падает (или тест его случайно закрывает), последующие тесты упадут. 

Нужно добавить валидацию фикстуры перед каждым тестом. Затем для финализации сделать отдельную функцию, которая должна выполняться автоматически в самом конце (даже если нигде в явном виде не вызвается).

Тестам требуется авторизованная сессия, поэтому следует добавить проверку предусловий в логин и логаут.

---
lessson12
Где может оказаться полезной конструкция if else

---
lesson13
Как сделать интелектуальный логин


---
lesson14
Как обеспечить выполнение предусловий

Может возникнуть проблема при выполнении теста удаления группы, если в списке нет ни одной группы.
Способы решения:
1) упорядочевание тестов (оптимизация)
2) добавить проверку предусловия в тест (становятся независимыми и устойчивыми)

Но добавить проверку в метод delete_first_group() вместо теста нельзя.

Фикстура должна оставаться пассивной и автоматически не делать ничего такого, что может исказить результаты тестирования.
Если сказано удалить первую группу, то должна удалить или сообщить об ошибке.
Вся логика должна быть сосредоточена в тестовых функциях или в функциях, которые создают фикстуру. Потому что для разных тестов может потребоваться разные предусловия.

Выполнение предусловий зона ответственности тестов. Каждый тест обеспечивает те предусловия, которые нужны ему.    

---
lesson15
Как оптимизировать переходы 

Если уже находимся на странице, то на нее не надо переходить.

Дополнительное ожидание появления элементов полезно, когда страница обновляется динамически (элементы подгружаются с задержкой).

--
lesson16
Как сделать проверку условий и управлять потоком выполнения кода



--
lesson17
Как загрузить списки групп из ui



--
lesson18
Как сделать полноценную проверку списков

добавляем в тест удаления групп проверку списков 

если удалить из старого списка первую группу, то он должен совпасть с новым списком

#вырезка включает левую часть а, правую нет
old_group[0:1] = []

сравнение по физическому признаку
assert old_group == new_group
вылетает ошибка, так как сравниваются ячейки памяти а не содержимое (значения) списоков

для сравнения списков объектов нужно попределить функции сравнения самих объектов (сравниваться будет значение и порядок)

добавить функциию, которая определяет как будет выглядеть наш объект при выводе на консоль
(строковое представление)
def __repr__(self):

для сравнения по логическому признаку нужно определеить функцию
def __eq__(self, other):

---
lesson19
Как сравнивать списки 

добавляем проверку поэлементного сравнения групп

сравниваем группы отсортированные по id

важно! при добавлении той же группы в старый список, у нас по дефолту id = None. 
То есть на момент сравнения мы не можем знать какой присвоется id
Но мы знаем что функция append добавляет элемент в конец списка т.е. None находится в конце списка.
Поэтому можем присвоить ему макс большое значение чтобы группа оказалась на последнем месте


напишем функцию, которая будет вычислять по группе ключ, используемый для сравнения

в питоне нет макс числа, поэтому используется константа maxsize (макс число используемое в списках)

в питоне нет автоматичского преобразования строк в числа и наоборот. поэтому преобразуем явно строку в число.

строки сравниваются в лексикографическом порядке 100 < 20

id сравниваем если они определены

---
lesson20
Как оптимизировать тесты

кеширование - хранилище, для повторного использования данных

Метод get_group_list будет работать с переменной group_cashe, и будет возвращать ее копию list(self.group_cashe)

Добавим очистку кеша в методы создания, изменения и удаления групп (так как в эти моменты кэш становится невалидным)

хеширования - хеш функция, которая выполняется быстрее и может использоваться для предварительной проверки 

--
lesson21
Как выбрать группу случайным образом

лучше методы модифицировать а не удалять, чтобы нигде ничего не сломалось
методы могут вызывать более сложные методы 


---
unit5
lesson22
Как работать со строками

строка - это последовательность символов

мы можем построить новую строку из кусочков старой, но старая останется неизменной

форматирование
return "%s:%s" % (self.id)

"(" + username + ")"
"(%s)" % username

--
lesson23
Как работает метод прямых проверок

нарезка и сравнение объектов

резать строки splitlines() и регулярных выражений
замены для приведения строк к единому виду 


---
lesson24
Как работает метод обратных поверок

склеивание и сравнение 

сначала убираем none строки (потому что функция clear не умеет работать с none)
затем очищаем clear от лишних символов, 
потом убираем пустые строки (которые могли появится в результате очистки)

Применить функцию ко всем элементам списка 

map(lambda x: clear(x), [])
в качестве первого параметра - каждый х превращается в очищенный
второго параметра - наш список к которому применяем функцию


оставить строчки для каждого х которые не пустые
filter(lambda x: x != '', [])

--
lesson25
Как сделать параметризованные функции и создать генератор тестовых данных 

Data Driver Testing - подход при котором тестовые данные отделены от сценариев (когда многократно разные тестовые данные прогоняют на тех же сценариях)

чтобы было видно с точки зрения отчетности, на каких тестовых данных и сколько раз проверяли
и с точки зрения стабильности, чтобы при падении на каком то наборе выполнение продолжалось на остальных наборах

нужно отказаться от использования цикла внутри теста и перенести тестовые данные на один уровень выше, так чтобы они передавались внутрь тестовой функции в качестве параметра 

вытаскиваем тестовые данные на уровень теста
добавляем параметр в тест
передавать параметр будет pytest по метке @pytest.mark.parametrize (параметр, источник)

чтобы увидеть на каких данных запускались тесты, нужно добавить список с их текстовым представлением - он указывается в параметре 
ids = [repr(x) for x in testdata] 

repr(obj) Return the canonical string representation of the object

он должен быть такой же длины как список с тестовыми данными, их нужно преобразовать в строки

превратить набор случайных символов в строчку (склеивание)
"".join(набор символов)

сделать один тест с пустыми а остальные со случайными данными 
вытаскиваем одну группу в отдельный короткий список + длинный список, построенный с помошью конструкции list comprehention (понимания)

testdata = [] + [генератор символов for i in range(2)]

2 раза сгенирируется список со случайными данными, а еще к нему добавится короткий список , содержащий пустые строки


testdata = [Group(name="", header="", footer="")] + [
    Group(name=random_string('name', 10), header=random_string('header', 20), footer=random_string('footer', 20))
    for i in range(2)]

или 


testdata = [Group(name=name, header=header, footer=footer)
            for name in ["", random_string('name', 10)]
            for header in ["", random_string('header', 20)]
            for footer in ["", random_string('footer', 20)]
            ]

н-р, name пробегает по двум возможным значениям 
аналогично остальные параметры
возникают комбинации параметров - полный перебор 2**3 всего 8 тестов


при отладке лучше использовать валидные и простые данные, когда тесты стали стабильными 
- лучше добавлять случайные данные 

--
lesson26
Как параметризовать весь тестовый набор целиком 

добавление параметров, которые определяют конфигурацию всего тестового набора

raise - аварийное исключение 

хуки (зацепки) - функции, которые можно реализовать в файле conftest, чтобы они в нужный момент вызвались фреймворком

например, в pytest_addoptions() в параметр передается парсер командной строки    


def pytest_addoption(parser):
   parser.addoption(browser = 'firefox')

получить значение переданного параметра можно через объект request

request.getopption('--browser') 

и именно его будем передавать в конструктор Application

активируем виртуальное окружение
C:\Users\Admin\Documents\GitHub\python_test\env\Scripts>activate

запускаем тест 
(env) C:\Users\Admin\Documents\GitHub\python_test>py.test --browser=firefox test\test_del_contact.py
или 
(env) C:\Users\Admin\Documents\GitHub\python_test>pytest --browser=firefox test\test_add_group.py

нужно иметь соответствущий исполняемый файл, например geckodriver.exe 

чтобы задать параметры из ide нужно открыть конфиг теста и вставить в поле Addition Arguments название параметра и значение
browser=firefox

--
unit6
lesson27 
Как читать и записывать данные в файл

Функция создания фикстуры выполняется перед каждым тестом, поэтому каждый раз читать данные из файла не имеет смысла. 
Делать это стоит в самом начале, повторно это делать необходимости нет. Поэтому сделаем также как с фикстурой.

Когда код запускается из ide, то текущей рабочей директорией является не директория проекта, а директория в которой находится исполняемый файл python.exe

В конфиге теста нужно указать директорию проекта 

--
lesson28
Как получить текущую директорию 

Альтернативный способ  - относительно файла conftest (директории проекта)

__file__ переменная, которая содержит путь до текущего файла (в данном случае conftest)

Сначала получим абсолютный путь до этого файла, 
затем определим директорию этого файла (директория проекта), 
далее нужно этот путь приклеить к конфигурационному файлу

os.path.join = ( директория,  то что собираемся подклеить)

в результате полученный путь сохраняем в переменную и открываем ее на чтение 


--
lesson29
Как сделать разделение по зонам ответственности 

Отделим сценарии от тестовых данных
Создадим новый пакет, поместим туда файл с тестовыми данными, которые представляют собой код на языке питон

--
lesson30
Как записать сгеренированные данные в файл  

Создадим отдельный модуль и перенесем туда часть кода, которая гененирует данные
Определим путь к файлу, в который будут сохраняться данные
Открываем файл на запись и записываем 
f.write(json.dumps())
функция dumps() превращает некоторую структуру данных в строку в формате json

TypeError: Object of type Group is not JSON serializable

dumps() не знает как преобразовывать объект group в формат json, поэтому надо определить функцию default() которая будет во всех случаях преобразовывать когда json не знает как преобразовывать данные

Он сначала применит функцию, которая указана в параметре default, а потом этот результат повторно попробует преобразовать в формат json

Превратим объект group в словарь
lambda x: x.__dict__, indent=2
у каждого объекта есть свойство __dict__, которое хранит теже свойства, которые мы присваиваем в поля конструктора __init__ self
параметр indent добавляет форматирование

Как сделать генератор тестовых данных параметризованным

https://docs.python.org/3/library/getopt.html?highlight=getopt


добавляем парсер командной строки - блок try - except
определяем 2 переменные - количество объектов и файл для записи
добавляем цикл for 

в конфиге указываем
-n3 -fdata/test.json

---
lesson31
Как загрузить данные из файла

Реализуем динамическое связывание тестовых функций с данными через фикстуру 

Вместо метки @pytest.mark.parametrize добавим в файл conftest специальную функцию (хук) pytest_generate_tests()

В качестве параметра в нее передается особый объект (тестовая функция), через который можно получить полную информацию о тестовой функции (ее фикстурах т.е. параметрах) 

Будем использовать фикстуры, начинающиеся с префикса data_

пробегаем по всем параметрам (fixturenames) и ищем название содержащее data_

как только встретилась такая фикстура, берем тестовые данные из модуля (который имеет такое же название как фикстура data_groups, но обрезанное без data_)

с помощью функции parametrize() загруженные тестовые данные помещаем в параметр тестовой функции:
Куда? в качестве значения той самой фикстуры
Какие? тест дата
Как? строкое представление


--
lesson32
Как загружать данные из json

Будем использовать еще одну разновидность фикстур, которые будут связывать тестовые функции с данными, хранящиеся в файлах начинающиеся с префикса json

Как только встречается фикстура json_ должен загрузиться файл из пакета data

добавляем условие в pytest_generate_tests() 

чтобы прочитать данные из json нужно к имеющимся свойствам объекта group добавить еще одно - класс, который укажет на то, что данные относятся к имеено group

читать и записывать данные будем с помощью либы https://jsonpickle.github.io/

меняем генератор
добавляем в conftest функцию, которая будет читать json

---
unit7
lesson33
Как установить соединение с бд

Скачать драйвер для бд
https://dev.mysql.com/doc/connector-python/en/

Если в репозитории хранится внешняя ссылка на пакет, то нужно явно разрешить проход
pip install --allow-external mysql-connector-python mysql-connector-python

Написать скрипт, который проверит соединение (вернет названия всех групп)

установка соединения
чтение в блоке try-finally потому что если произойдет невалидный запрос, посыпятся исключение то нужно закрыть соединение
курсор - это указатель на результат выполнения запроса. Представляет собой таблицу из набора строк. Чтобы их их получить нужно использовать fetchall



lesson34
Как создать фикстуру для бд

Есть два способа
- добавить помощник и сделать его частью application. Если всегда нужно инициализировать все части, когда надо запускать браузер и бд.
- сделать отдельную независимую фикстуру (добавить в файл conftest функцию, которая будет ее инициализировать и добавить отчистку). Если есть самостоятельные тесты, которые работают отдельно.

Сделаем отдельную. Добавим функцию def db(request) в файл conftest
Сделаем простую, будем предполагать что она не испортится в процессе и в конце останавливать

Инициализировать будем не соединение, а новый класс DbFixture

В фикстру, т.е. в конструктор класса нужно передать параметры (host, database, username, password)

Лучше эти параметры хранить в файле в конфиге target, 

Разделим параметры на два блока web & db

Теперь надо переделать загрузку параметров в conftest.
Поскольку загружаться параметры будут в двух разных фикстурах (функциях app() и db()) то имеет смысл выделить загрузку в отдельную функцию.

Добавляем необходимые аргументы в конструктор класса DbFixture

и сразу установим соединение 





























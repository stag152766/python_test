# python_test
 
unit1

pip install virtualenv 

cd / корень проекта

создание вирутального окружения
virtualenv env 

активация  
env\Scripts\activate

установка в виртуальное окружение
pip install seleninum
pip install pytest

обновление chromedriver 
https://sites.google.com/a/chromium.org/chromedriver/downloads

переключение тест раннера
settings > tools > Python Integreted Tools > Default Test Runner

метод - это функция, которая размещена в каком-то классе
self обязательный параметр метода, указывающий на объект в котором этот метод вызван

unittest
объединение методов в один класс позволяет обмениваться данными (ссылкой на драйвер) между собой через объект этого класса (его поля)

Если мы не явно запустили unittest (например, просто python test_add_group.py) то данные строчки подсказвают питону как этот скрипт толжен запускаться, он запустит сначала unittest а затем и сам тест 

if __name__	== '__main__':
	unittest.main()



В тестах надо явно задавать параметры, чтобы ситуация полностью контролировалась. Вспомагательные методы должны быть универсальными.

Вместо того, чтобы передать несколько параметров, нужно передавать объект(ы) (в которых хранится сгруппированные параметры - свойства). 
Для этого создается отдельный класс (файл), который моделирует предметную сущность.
В нем создается конструктор def __init___, который и будет принимать все значения параметров и записывать их в свойства объекта. 
Дальше, во все остальные методы будет передаваться один объект этого класса. 
Так как объект находится в отдельном файле, нужно его импортировать в тест

--- 
unit2
lesson7

Стек автотестирования

СИ (задача отслеживание изменений и автозапуск)
Сборщик (задача подгрузить доп зависимости)
Фреймворк
Тесты
Драйвер (прослойка из вспомогательных функций)
ТС 



команды уровня драйвера web ui

действия с тс
click()
clear()
send_keys()

получения информации из браузера
find_element_by()
find_elements_by()
text
get_attribute()
is_displayed()
location
size

---
lesson8

Фикстура (оснастка, фиксатор, в котором "зажимаем" тестируемую систему)

В начале производится инициализация. На этом этапе создается фикстура.
Примеры фикстур:
- браузер, управляемый драйвером
- соединение с базой данных

В pytest предполагается, что фикстура - это самостоятельный объект. Можно написать функцию, которая создает этот объект. 

@pytest.fixture
def app(request):
    fixture = Application()
    request.addfinalizer(fixture.destroy)
    return fixture

pytest непосредственно запускает тестовые функции (создания тестовых классов необязательно)

Когда pytest видит, что у тестового метода есть параметр, он пытается найти функцию с таким именем, и считает что эта функция должна создавать  объект- фикстуру. 
Этот объект передается как параметр в тестовый метод.

Для разрушения фикстуры в функцию инициализации передается параметр request, у которого есть метод addfinalizer(). В него нужно передать функцию, которая вызывает разрушение.
 
Драйвер инициализируется один раз, при создании фикстуры. Нужно передать эту информацию в помощник.

---
lesson9

Принцип разделения ответственности (декомпозиция: одна сущность - одна роль).

Маркер того, что это пакет
__init__.py 

Фикстура, которая должна быть общая для всех тестов, помещается в отдельный файл conftest.

Для того, чтобы использовать браузер для запуска всех тестов нужно указать свойство в метке 
@pytest.fixtura(scope="session")

В качестве дефолтного значения указывается None (т.е. поле не проинициализировано)

---
unit3
lesson11

Обеспечение проверки предусловий 

интелектуальная фикстура 

Следует избегать дублирования кода - повторение логина и логаута в каждом тесте. Для этого нужно перенести в фикстуру функцию логина и логаута (добавить действие в finalizer).

Все тесты выполняются в одном и том же бразузере и одной и той же сессии (оптимизация по скорости).

Если во время выполнения набора тестов бразузер падает (или тест его случайно закрывает), последующие тесты упадут. 

Нужно добавить валидацию фикстуры перед каждым тестом. Затем для финализации сделать отдельную функцию, которая должна выполняться автоматически в самом конце (даже если нигде в явном виде не вызвается).

Тестам требуется авторизованная сессия, поэтому следует добавить проверку предусловий в логин и логаут.

---
lesson14

Может возникнуть проблема при выполнении теста удаления группы, если в списке нет ни одной группы.
Способы решения:
1) упорядочевание тестов (оптимизация)
2) добавить проверку предусловия в тест (становятся независимыми и устойчивыми)

Но добавить проверку в метод delete_first_group() вместо теста нельзя.

Фикстура должна оставаться пассивной и автоматически не делать ничего такого, что может исказить результаты тестирования.
Если сказано удалить первую группу, то должна удалить или сообщить об ошибке.
Вся логика должна быть сосредоточена в тестовых функциях или в функциях, которые создают фикстуру. Потому что для разных тестов может потребоваться разные предусловия.

Выполнение предусловий зона ответственности тестов. Каждый тест обеспечивает те предусловия, которые нужны ему.    

---
lesson15
Оптимизация переходов 

Если уже находимся на странице, то на нее не надо переходить.

Дополнительное ожидание появления элементов полезно, когда страница обновляется динамически (элементы подгружаются с задержкой).

--
lesson18
добавляем в тест удаления групп проверку списков 

если удалить из старого списка первую группу, то он должен совпасть с новым списком

#вырезка включает левую часть а, правую нет
old_group[0:1] = []

сравнение по физическому признаку
assert old_group == new_group
вылетает ошибка, так как сравниваются ячейки памяти а не содержимое (значения) списоков

для сравнения списков объектов нужно попределить функции сравнения самих объектов (сравниваться будет значение и порядок)

добавить функциию, которая определяет как будет выглядеть наш объект при выводе на консоль
(строковое представление)
def __repr__(self):

для сравнения по логическому признаку нужно определеить функцию
def __eq__(self, other):

---
lesson19


добавляем проверку поэлементного сравнения групп

сравниваем группы отсортированные по id

важно! при добавлении той же группы в старый список, у нас по дефолту id = None. 
То есть на момент сравнения мы не можем знать какой присвоется id
Но мы знаем что функция append добавляет элемент в конец списка т.е. None находится в конце списка.
Поэтому можем присвоить ему макс большое значение чтобы группа оказалась на последнем месте


напишем функцию, которая будет вычислять по группе ключ, используемый для сравнения

в питоне нет макс числа, поэтому используется константа maxsize (макс число используемое в списках)

в питоне нет автоматичского преобразования строк в числа и наоборот. поэтому преобразуем явно строку в число.

строки сравниваются в лексикографическом порядке 100 < 20

id сравниваем если они определены

---
lesson20

кеширование - хранилище, для повторного использования данных

Метод get_group_list будет работать с переменной group_cashe, и будет возвращать ее копию list(self.group_cashe)

Добавим очистку кеша в методы создания, изменения и удаления групп (так как в эти моменты кэш становится невалидным)

хеширования - хеш функция, которая выполняется быстрее и может использоваться для предварительной проверки 
--
lesson21

выбор группы случайным образом


лучше методы модифицировать а не удалять, чтобы нигде ничего не сломалось
методы могут вызывать более сложные методы 


---
unit5
lesson22

DDT выполнение тестов на разных тестовых данных


строка - обычная последовательность

мы можем построить новую строку из кусочков старой, но старая останется неизменной

форматирование
return "%s:%s" % (self.id)

"(" + username + ")"
"(%s)" % username

--
lesson23

резать строки splitlines() и регулярных выражений
замены для приведения строк к единому виду 


---
lesson24

Метод прямых проверок: нарезка и сравнение объектов

Метод обратных проверок: склеивание и сравнение 

сначала убираем none строки (потому что функция clear не умеет работать с none)
затем очищаем clear от лишних символов, 
потом убираем пустые строки (которые могли появится в результате очистки)

Применить функцию ко всем элементам списка 

map(lambda x: clear(x), [])
в качестве первого параметра - каждый х превращается в очищенный
второго параметра - наш список к которому применяем функцию


оставить строчки для каждого х которые не пустые
filter(lambda x: x != '', [])

--
lesson25

Data Driver Testing - подход при котором тестовые данные отделены от сценариев (когда многократно разные тестовые данные прогоняют на тех же сценариях)

чтобы было видно с точки зрения отчетности, на каких тестовых данных и сколько раз проверяли
и с точки зрения стабильности, чтобы при падении на каком то наборе выполнение продолжалось на остальных наборах

нужно отказаться от использования цикла внутри теста и перенести тестовые данные на один уровень выше, так чтобы они передавались внутрь тестовой функции в качестве параметра 

вытаскиваем тестовые данные на уровень теста
добавляем параметр в тест
передавать параметр будет pytest по метке @pytest.mark.parametrize (параметр, источник)

чтобы увидеть на каких данных запускались тесты, нужно добавить список с их текстовым представлением - он указывается в параметре ids = [] 
он должен быть такой же длины как список с тестовыми данными, их нужно преобразовать в строки

превратить набор случайных символов в строчку (склеивание)
"".join(набор символов)

сделать один тест с пустыми а остальные со случайными данными 
вытаскиваем одну группу в отдельный короткий список + длинный список, построенный с помошью конструкции list comprehention (понимания)

testdata = [] + [генератор символов for i in range(2)]

2 раза сгенирируется список со случайными данными, а еще к нему добавится короткий список , содержащий пустые строки


testdata = [Group(name="", header="", footer="")] + [
    Group(name=random_string('name', 10), header=random_string('header', 20), footer=random_string('footer', 20))
    for i in range(2)]

или 


testdata = [Group(name=name, header=header, footer=footer)
            for name in ["", random_string('name', 10)]
            for header in ["", random_string('header', 20)]
            for footer in ["", random_string('footer', 20)]
            ]

н-р, name пробегает по двум возможным значениям 
аналогично остальные параметры
возникают комбинации параметров - полный перебор 2**3 всего 8 тестов


при отладке лучше использовать валидные и простые данные, когда тесты стали стабильными 
- лучше добавлять случайные данные 

--
lesson25
добавление параметров, которые определяют конфигурацию всего тестового набора

raise - аварийное исключение 

хуки зацепки - функци, которые можно реализовать в файле conftest чтобы они в нужный момент вызвались фреймворком

например, pytest_addoptions в параметр передается парсер командной строки    


def pytest_addoption(parser):
   parser.addoption(browser = 'firefox')

получить значение переданного параметра можно через объект request

request.getopption('--browser') 

и именно его будем передавать в конструктор Application

активируем виртуальное окружение
C:\Users\Admin\Documents\GitHub\python_test\env\Scripts>activate

запускаем тест 
(env) C:\Users\Admin\Documents\GitHub\python_test>py.test --browser=firefox test\test_del_contact.py
или 
(env) C:\Users\Admin\Documents\GitHub\python_test>pytest --browser=firefox test\test_add_group.py

нужно иметь соответствущий исполняемый файл, например geckodriver.exe 

чтобы задать параметры из ide нужно открыть конфиг теста и вставить в поле Addition Arguments название параметра и значение
browser=firefox

--
unit6
lesson27 






